# Flows

## Introduction

A **flow** is a simple yet very flexible mechanism that enables orchestration of services using the sophisticated message flow capabilities of Mule. Using a flow, you may automate integration processes and construct Mule message processing solutions by ordering any number of [elements of a Mule flow](https://docs.mulesoft.com/mule-runtime/3.9/elements-in-a-mule-flow) in a valid arrangement. Because what you do inside a flow is up to you as the developer, it is much easier to create solutions that match your requirements.

## When to Use a Flow

**A flow is the most versatile and powerful integration mechanism available in Mule.**

Flows are valuable in many situations, including:

- Simple integration tasks
- Scheduled data processing
- Connecting cloud and on-premise applications
- Event processing where multiple services need to be composed

## The Anatomy of a Flow

A flow is in essence just a chain of Message Processors. Think of each Message Processor as a Lego block where a Flow is something you build with them. A flow also has a message source, the source of messages that are processed by the Message Processor chain.

![flow](https://docs.mulesoft.com/mule-runtime/3.9/_images/flow.jpg)

## Flow Configuration

A Flow is configured in XML using the <flow> element. Each flow has a name attribute, a message source (unless it’s a private flow), one or more message processors and an optional exception strategy.

**Basic Structure**

```xml
<flow name="">
    - 0..1 MessageSource
    - 1..n MessageProcessor(s)
    - 0..1 ExceptionStrategy
</flow>
```

Flows seem simple, yet can be quite powerful. In particular, when combined with expressions in Mule, they can allow for very sophisticated processing of the message contents. There are many elements that leverage expressions, including:

- [Transformers](https://docs.mulesoft.com/mule-runtime/3.9/using-transformers)
- Filters
- [Routing](https://docs.mulesoft.com/mule-runtime/3.9/routers)
- [Message Enricher](https://docs.mulesoft.com/mule-runtime/3.9/message-enricher)

## Example

**Simple Book Order Processing Flow**

```xml
<flow>
    <file:inbound-endpoint path="/myDirectory">
        <file:filename-filter name="*.xml"/>
    </file:inbound-endpoint>
    <xml:xslt-transformer xsl-file="bookOrderTransformation.xsl"/>
    <splitter expression="xpath://order"/>
    <!-- The following message processors will be invoked for each order in the XML file -->
    <expression-filter expression="xpath://order[@type='book']"/>
    <component class="org.my.BookOrderProcessor"/>
    <smtp:outbound-endpoint subject="Order Confirmation" address=""/>
    <jdbc:outbound-endpoint />
    <default-exception-strategy>
        <jms:outbound-endpoint queue="failedOrders"/>
    </default-exception-strategy>
</flow>
```

## Flow Behavior

When a message is received or generated by the message source the flow is started and the configured message processors are invoked in a chain in the same order as they are configured. Some message processors accept child message processor elements, in this case these are processed before returning and continuing processing the main list.

The above describes the behavior when the flow is *one-way*. If the flow is *request-response* because an inbound endpoint as a *request-response* exchange pattern defined then the result of the flow execution is return to the inbound endpoint and then in turn to the callee. If there are no *<response>* blocks in your flow and if none of the configured message processors perform any response processing then the response used is simply the result from the last Message Processor in the flow. If a *<response>* block is used, then any message processors configured in this element are used to process the response message. Some message processors such as CXF perform processing of the response message as part of their default configuration.

**Note**: When the last element in the flow configuration is a *one-way* *<outbound-endpoint>* there’s no result of it’s execution so the returned payload of the message is going to be NullPayload. If the *one-way* *<outbound-endpoint>* is followed by another processor, it receives as input the same message that the outbound-endpoint receives instead of NullPayload.

![flowrr](https://docs.mulesoft.com/mule-runtime/3.9/_images/flowrr.jpg)

## Private Flows

A private flow is one that cannot be accessed from outside the JVM via a [Mule Endpoint](https://docs.mulesoft.com/mule-runtime/3.9/endpoint-configuration-reference) because it has no message source defined.

Private Flows are therefore only used if they are referenced from another construct running in the same Mule instance. When configuring Mule using XML the *<flow-ref>* element is used to include one flow in another.

A private Flow differs from the use of a "Processor Chain" in that a Flow has it’s own context and exception strategy where as when a processor chain is referenced, it is executed in the context of the flow that references it.

**Private Flow Example**

```xml
<flow name="privateFlow">
  <append-string-transformer message="b"/>
</flow>

<flow name="publicFlow">
  <http:inbound-endpoint address="http://localhost:8080"/>
  <append-string-transformer message="a"/>
  <flow-ref name="privateFlow"/>
  <append-string-transformer message="c"/>
</flow>
```

## Further Reading

You can read more about the reason we added Flow for Mule 3 in the following blog posts:

- [Mule 3 Architecture, Part 1: Back to Basics](https://blogs.mulesoft.com/dev/mule-dev/mule-3-architecture-part-1-back-to-basics/)
- [Mule 3 Architecture, Part 2: Introducing the Message Processor](https://blogs.mulesoft.com/dev/mule-dev/mule-3-architecture-part-2-introducing-the-message-processor/)





# 流动

## 介绍

一个**流**是一个简单但非常灵活的机制，使得使用骡子的复杂的消息流功能服务的编排。使用流，您可以通过在有效排列中排序[Mule流的](https://docs.mulesoft.com/mule-runtime/3.9/elements-in-a-mule-flow)任意数量的[元素](https://docs.mulesoft.com/mule-runtime/3.9/elements-in-a-mule-flow)来自动化集成过程并构建Mule消息处理解决方案。因为您在流程中所做的事情取决于您作为开发人员，所以创建符合您要求的解决方案要容易得多。

## 何时使用流程

**流是Mule中最通用和最强大的集成机制。**

流量在许多情况下都很有价值，包括：

- 简单的集成任务
- 预定数据处理
- 连接云和内部部署应用程序
- 需要组合多个服务的事件处理

## 流动的剖析

流程本质上只是一个消息处理器链。将每个消息处理器视为乐高块，其中Flow是您使用它们构建的。流还具有消息源，消息源由消息处理器链处理。

![流](https://docs.mulesoft.com/mule-runtime/3.9/_images/flow.jpg)

## 流量配置

使用<flow>元素在XML中配置Flow。每个流都有一个名称属性，一个消息源（除非它是一个私有流），一个或多个消息处理器和一个可选的异常策略。

**基本结构**

```xml
<flow name="">
    - 0..1 MessageSource
    - 1..n MessageProcessor(s)
    - 0..1 ExceptionStrategy
</flow>
```

流程似乎很简单，但却非常强大。特别是，当与Mule中的表达式结合使用时，它们可以允许对消息内容进行非常复杂的处理。有许多利用表达式的元素，包括：

- [变形金刚](https://docs.mulesoft.com/mule-runtime/3.9/using-transformers)
- 过滤器
- [路由](https://docs.mulesoft.com/mule-runtime/3.9/routers)
- [消息丰富](https://docs.mulesoft.com/mule-runtime/3.9/message-enricher)

## 例

**简单的图书订单处理流程**

```xml
<flow>
    <file:inbound-endpoint path="/myDirectory">
        <file:filename-filter name="*.xml"/>
    </file:inbound-endpoint>
    <xml:xslt-transformer xsl-file="bookOrderTransformation.xsl"/>
    <splitter expression="xpath://order"/>
    <!-- The following message processors will be invoked for each order in the XML file -->
    <expression-filter expression="xpath://order[@type='book']"/>
    <component class="org.my.BookOrderProcessor"/>
    <smtp:outbound-endpoint subject="Order Confirmation" address=""/>
    <jdbc:outbound-endpoint />
    <default-exception-strategy>
        <jms:outbound-endpoint queue="failedOrders"/>
    </default-exception-strategy>
</flow>
```

## 流动行为

当消息源接收或生成消息时，将启动流，并按照与配置相同的顺序在链中调用配置的消息处理器。一些消息处理器接受子消息处理器元素，在这种情况下，这些元素在返回并继续处理主列表之前被处理。

以上描述了流量为*单向*时的行为。如果流是*请求 - 响应，*因为入站端点定义为*请求 - 响应*交换模式，则流执行的结果将返回到入站端点，然后又返回到被调用者。如果流中没有*<response>*块，并且没有配置的消息处理器执行任何响应处理，则使用的响应只是流中最后一个消息处理器的结果。如果是*<response>*使用块，然后使用此元素中配置的任何消息处理器来处理响应消息。某些消息处理器（如CXF）会将响应消息的处理作为其默认配置的一部分。

**注意**：当流配置中的最后一个元素是*单向* *<outbound-endpoint>时*，没有执行它的结果，因此返回的消息有效负载将是NullPayload。如果*单向* *<outbound-endpoint>*后跟另一个处理器，则它接收出站端点接收的相同消息而不是NullPayload作为输入。

![flowrr](https://docs.mulesoft.com/mule-runtime/3.9/_images/flowrr.jpg)

## 私人流动

私有流是无法通过[Mule端点](https://docs.mulesoft.com/mule-runtime/3.9/endpoint-configuration-reference)从JVM外部访问的私有流，因为它没有定义消息源。

因此，仅在从同一Mule实例中运行的另一个构造引用私有流时才使用私有流。使用XML配置Mule时，*<flow-ref>*元素用于在另一个流中包含一个流。

私有流与使用“处理器链”的不同之处在于，Flow具有自己的上下文和异常策略，当引用处理器链时，它在引用它的流的上下文中执行。

**私人流程示例**

```xml
<flow name="privateFlow">
  <append-string-transformer message="b"/>
</flow>

<flow name="publicFlow">
  <http:inbound-endpoint address="http://localhost:8080"/>
  <append-string-transformer message="a"/>
  <flow-ref name="privateFlow"/>
  <append-string-transformer message="c"/>
</flow>
```

## 进一步阅读

您可以在以下博客文章中详细了解我们为Mule 3添加Flow的原因：

- [Mule 3架构，第1部分：回归基础](https://blogs.mulesoft.com/dev/mule-dev/mule-3-architecture-part-1-back-to-basics/)
- [Mule 3架构，第2部分：消息处理器简介](https://blogs.mulesoft.com/dev/mule-dev/mule-3-architecture-part-2-introducing-the-message-processor/)
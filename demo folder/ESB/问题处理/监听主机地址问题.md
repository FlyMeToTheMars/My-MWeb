# 本机ip、127.0.0.1和0.0.0.0区别

## 问题背景：

部署Mule ESB时，application中的监听地址被我设置为 `localhost`，本地跑服务，浏览器访问都没问题。

但是，当部署到测试机后，发现访问不到。 这各问题通过将 `localhost`修改为 `0.0.0.0` 得以解决。



## IP地址的记法：

IP地址由四个字节构成，为了方便[阅读](http://book.2cto.com/)和书写，每个字节用0-255的数字表示，字节之间用’.'分割，如：

10.10.152.235

有时候我们会看到这样的IP：

10.10.152.235/24，

后面的/24表示子网掩码，24表示子网掩码上有24个1，等价于255.255.255.0 。

IP地址和子网掩码按位 与，得到的是 网络号（Network ID），

剩余的部分是子网内的 主机号（host ID，当然，这个名字小有问题，因为现在有IP的可不仅仅是主机，暂且这么称呼吧），

## 特殊的IP地址段：127.x.x.x

这是大家最熟悉不过的本地loopback地址，在windows和linux上等价于localhost。

我们习惯于使用127.0.0.1，实际上，

如果你在命令行下ping 127.0.0.1-127.255.255.254之间的任意地址，结果都是一样的，它们是等价的。

正常的网络包从ip层进入链路层，然后发送到网络上，

而发向loopback地址的包，直接在IP层短路了，也就是发到IP层的包直接被IP层接收了，不再向下发送。

私网地址段：

10.x.x.x、192.168.x.x、172.16.x.x～172.31.x.x、169.254.x.x

这些私网地址段是不允许出现在Internet上的，主用保留用于企业内部[组网](https://www.2cto.com/net/lan/buxian/)使用，

这可以在一定程度上缓解IP地址不够用的问题。

大型企业的OA网用10地址段的比较多，因为这是一个A类地址段，包含的IP很多。

小公司用192.168.0地址段的比较多。

而169.254则主要是分配给DHCP服务使用的。

保留地址段：

128.0.x.x、191.255.x.x、192.0.0.x、233.255.255.x

这些地址被保留起来，不做分配且没有明确的用途。

其它特殊IP：

255.255.255.255是全局广播地址，

主机号全部为1的地址是子网广播地址，如：192.168.1.255

主机号全部为0的地址是代表该子网的网络地址，如：192.168.1.0

## 一个非常特殊的IP：0.0.0.0

这个IP相当于java中的this，代表当前设备的IP。

我们在java[编程](https://www.2cto.com/kf)中使用ServerSocket做网络侦听，通常只需要如下代码：

ServerSocket serverSock=new ServerSocket(8888);

serverSock.accept();

假如我的主机ip为：10.10.152.8，

用以上代码做侦听，127.0.0.1:8888或者10.10.152.8:8888都可以连上，

但大家有没有想过过，这个ServerSocket到底使用哪个IP在做侦听？

如果我们将以上代码改成显式绑定：

ServerSocket ss=new ServerSocket();

String ip=“10.10.152.8″;

int port=8888;

InetSocketAddress addr=new InetSocketAddress(ip,port);

ss.bind(addr);

ss.accept();

你会发现，127.0.0.1:8888是无法访问的，

而如果将ip改成127.0.0.1，那么10.10.152.8:8888是无法访问的。

实际上，背后的秘密就在与0.0.0.0这个IP，他可以代表本机的所有IP地址，

但这个IP并不是真是存在的，我们ping不通它，如果将ip改成0.0.0.0:

ServerSocket ss=new ServerSocket();

String ip=“0.0.0.0″;

int port=8888;

InetSocketAddress addr=new InetSocketAddress(ip,port);

ss.bind(addr);

ss.accept();

我们会发现，这和默认行为是一样的，127.0.0.1:8888或者10.10.152.8:8888都可以连上。